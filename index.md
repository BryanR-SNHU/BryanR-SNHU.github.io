## CS499 ePortfolio

This capstone course has resulted in me building a portfolio that showcases my abilities as a software developer. Returning to past projects has allowed me to apply the skills acquired over the course of my education. My previous classes taught me how to collaborate with multiple developers on a shared git repository. This gave me the ability to merge branches while solving conflicts, and communicate with a team to achieve acceptable outcomes. In CS330, I learned how to configure a build environment to develop a complex 3D graphics application that tied together several libraries and the OpenGL API. In the process of enhancing my artifact from that class, I produced an expandable and maintainable improvement on the original project. In CS260, I was introduced to a variety of data structures, such as linked lists and binary trees. I learned the strengths and weaknesses of the structures and formed an idea of where to best use them. I also learned about several sorting algorithms, and their proper application. My enhancement to a binary tree example program involved transforming a technical demonstration into a practical tool. In CS340 I learned about combining databases with server infrastructure, culminating in a HTTP API used to interface with a mongoDB database. This linked together my basic knowledge of databases with a convenient interface to the raw structure. My enhancement to this project was an actual web interface to the underlying API. This involved serving a static HTML page along with javascript to perform proper requests to the API. My previous classes have taught me how to code securely, by following best practices and specific organization guidelines. This includes guarding against common problems such as over/underflows and code injection. I have applied this knowledge to applications I have worked on since then and strive to produce secure, easily inspected code. Finally, I have learned how to perform code reviews. This has let me examine my own and others code in a critical manner that allows me to constructively build on the existing functionality and improve deficiencies.
 
## Code Review
 
[Code review on Youtube](https://youtu.be/fLc67JjCYO0)
 
## Artifact I.
 
[Artifact I. Link](https://github.com/BryanR-SNHU/CS330)
 
The artifact used in this first enhancement is the final project from CS330 Computational Graphics and Visualization. It is a 3D model viewer that displays a hand coded model of a fork. The application allows pitch, yaw, and zoom adjustment by holding down the left or right mouse buttons. Additionally, the w, s, and p keys toggle a variety of display options.

In its initial form, this artifact was already a good demonstration of wrangling a complex application. It made use of multiple libraries related to graphics driver interfacing and data manipulation. The program makes use of both C++ and the glsl shader language. Debug data is extracted from the GPU driver in the case of shader compilation errors, easing development that is otherwise tedious. With all that said, there was still plenty of room to improve the project.

My improvements to the artifact largely focused on reducing clutter and increasing modularity. The original version of the project packed all functionality into one file. It also made use of a long list of global variables. In the enhanced version of the application, meshes have become a class that incorporates the functionality of creating and displaying buffers in easy methods. Rather than individually handle displaying these meshes, they are grouped into a “MeshGroup” class. The “MeshGroup” class also stores a shared texture reference used by all sub meshes. Refactoring meshes and their management into dedicated classes has reduced a lot repetitive code related to creating and displaying elements of a model. The other significant change is moving the shader code into separate source files. This makes them easier to develop, as they can benefit from syntax checking when not in a character literal form. The application now converts the shader source files into strings that can be provided to the OpenGL driver. Other than these major changes, I adjusted formatting and fixed typos in documentation. I believe that the changes I have made go a long way toward making the application more maintainable and more adaptable. These enhancements are examples of a more maintainable, approachable, and secure approach to development than the original artifact.

Enhancing this artifact really made me appreciate the difficulty of returning to old code. Not just the process of getting up to speed, but the discomfort of seeing your old mistakes. Graphics interface code is somewhat odd, and it took some time to get back in the swing of things. While relearning how my application worked was challenging, I enjoyed planning out and implementing improvements. There was a real sense of satisfaction and accomplishment in getting to do it right.
 
## Artifact II.
 
[Artifact II. Link](https://github.com/BryanR-SNHU/CS260-BinarySearchTree)
 
The artifact I chose for this enhancement is the binary search tree example from CS260 Data Structures and Algorithms. In its original form, it was a simple demonstration of the process of reading a csv file and placing its contents into a binary tree structure. The application also allowed adding and removing nodes from the tree.

The original version of this application is not very useful as a practical tool, but is a good example of properly deploying a basic data structure. Recursion can be a tricky topic to grasp, and it is used in several parts of the application. Recursion is necessary for any function that traverses the tree, as the structure has no fixed depth. In order to make the application more practical, I decided to focus on adding features.

I improved the application by giving it the ability to output the modified binary tree structure. This required me to study the JSON format and ensure my application output standards  compliant JSON. In the process of implementing the JSON feature, I also refactored the entire project. All classes now have their own source and header files. This has made the project much more maintainable by encapsulating the functionality of a class into one place that can be easily searched for. I added a default handler to the menu switch/case statement to bring it more in line with best practices about giving feedback to the user. Instead of silently dropping bad inputs, an error message is shown. While documenting the new methods for the JSON feature, I also improved the existing documentation by filling in some blanks and normalizing some formatting. The original version of this project is a time capsule that shows what I was capable of at an earlier part of my education. The enhancements I’ve made all combine to make an application that is more in line with my current understanding of practical, adaptable, and secure development. The code now strives to solve things in common, C++ standard ways. Functionality is implemented in the most straightforward way possible, rather than attempting to sacrifice readability for “elegance”.

One of the difficulties I faced when working on this artifact was reassembling a working application from one source file. Back when I saved my work for this project, I only kept the BinarySearchTree.cpp file that I submitted. I needed to search online to locate the additional files for csv parsing and the csv file itself. Besides that main problem, I had to get very familiar with both the JSON format and manipulating strings in C++. No matter how many times I learn how strings work in C++, I always seem to need to relearn them for each project.
 
## Artifact III.
 
[Artifact III. Link](https://github.com/BryanR-SNHU/CS340)
 
For this enhancement, I chose the module 7 assignment from CS340 Client/Server Development. This is a python based RESTful web server that acts as an API for a mongoDB database. The application demonstrates a variety of features required in a CRUD (Create, Read, Update, Delete) database interface. The API provides several query interfaces, as well as update and delete options.

The application in its initial form has some severe drawbacks, both as a practical interface and as a portfolio demonstration. The only way to interface with the API is through raw GET, POST, and PUT requests using a tool like curl. While this was acceptable in the original assignment submission, it is unacceptable in the real world. No one can be expected to open a shell and type in handcrafted HTTP requests.

My enhancements to the application consist of an HTML based interface to the API and javascript to provide the functionality. The first change is a HTML form based index page that is displayed when the root of the web server is visited. Before, only the API endpoint URLs provided any response, and visiting the root location would have returned an error. The interfaces to the various API functions are provided using simple HTML forms. These forms would not interface with the API in their standard form, so they are augmented with javascript. The submit function of each form is intercepted in “module7.js” in order to use the form data to perform other requests. Some of the endpoints are accessed using the end of the URL as a parameter. In these cases, the form text is simply appended to the end of the appropriate URL and loaded. Other endpoints require a combination of POST or PUT requests along with a dynamic URL. For these the input is still a form, but the javascript function will convert the values from the form into the appropriate format for the receiving API function. In summary, this enhancement was essentially building a web based application to use the existing API.

My main difficulty in developing this enhancement was related to the awkwardness of debugging the features through a combination of a web browser and command line. Certain aspects had to be verified though my browsers debugging tools, such as seeing the contents of requests and responses. Errors within the Bottle server would show up in a separate shell window. Mistakes in the javascript had to be discovered through javascript console printing and page alerts. Much of the difficulty came from how long it’s been since I used HTML.
 
